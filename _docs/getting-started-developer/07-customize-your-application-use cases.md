---
title: "Customize your application - Generate Use Cases"
permalink: /averos/getting-started-developer/customize-your-application-use-cases/
excerpt: "Customize your application - Generate Use Cases"
toc: true
---

### **I. Introduction**

You have so far defined the application business requirement as well as the target application design then generated a first version of your `ToDoApplication` with **authentication** and **user management** capabilities. <br/>
Then, you have used `averos commands workflows` to generate your business entities along with their members and their relationships. <br/>
You have also generated the entity managing services and bound them to their `APIs backend services` using `averos configuration command workflow`.<br/>
Finally, you have re-built and redeployed a new version of your application then singned into it.<br/>

Much to your surprise, your new application version is just the same as the first version. <br/> Or is it not ? <br/>

Well, your new application is not exactly the same as your first version, since now you have additional implementations and configurations that occured under the hood.<br/>

However, the user interface is still the same since no use case has been introduced into the application yet. <br/>

Remember those business requirements you defined in the design step ?<br/>
Well it is high time you generate all of them into your application within minutes! <br>

In this chapter we are going to use `averos framework` to implement our use cases and start to experience them through our application.<br/>

### **II- Generate Use Cases**

Let's step back for a moment and recall the use cases we designed earlier.<br/>

<figure align="center">
	<a href="{{ site.baseurl }}/assets/arch/tutorial/to-do-area- use-case-diagram.png">
    <img src="{{ site.baseurl }}/assets/arch/tutorial/to-do-area- use-case-diagram.png" alt="ToDoArea Use Case Diagram">
      <figcaption>ToDoArea Use Case Diagram</figcaption>
  </a>
</figure>


<figure align="center">
	<a href="{{ site.baseurl }}/assets/arch/tutorial/to-do-task-use-case-diagram.png">
    <img src="{{ site.baseurl }}/assets/arch/tutorial/to-do-task-use-case-diagram.png" alt="ToDoTask Use Case Diagram">
      <figcaption>ToDoTask Use Case Diagram</figcaption>
  </a>
</figure>

According to our design, each business entity that is managed by an **averos service**, is subject to one or more use cases. <br/>

Let's check them out one by one.

#### **1. `ToDoArea` Use Cases**

Our `ToDoArea` entity is subject to the following actions:
   >
  - [x] **Create**
  - [x] **Search** (based on criteria filter)
  - [x] **Export** (to Excel format)
  - [x] **Update/Modify**  
  - [x] **Delete**
  - [x] **Assign** `ToDo Tasks` (a user can assign one or several tasks to a specific area of interest)
  - [x] **Unassign** `ToDo Tasks` (a user can unassign one or several tasks from a specific area of interest)

So as a result if you are willing to implement all of these use cases you might want to go ahead and create simple angular components for each one, then add your use case logic by designing your user interfaces, implementing the related actions and 

```bash
ng g @wiforge/averos:advanced-crud --ename=ToDoArea --defaults 
```


The output of the command should look like the following one:

<figure align="center">
	<a href="{{ site.baseurl }}/assets/tutorial/developer/12-todoarea-crud-output.png">
    <img src="{{ site.baseurl }}/assets/tutorial/developer/12-todoarea-crud-output.png" alt="ToDoArea CRUD Command Output">
      <figcaption>ToDoArea CRUD Command Output</figcaption>
  </a>
</figure>

Now how about getting a glimpse on what have changed in our application after adding `ToDoArea` use cases ?
Sounds great ?<br/>
Then go ahead and re-build/re-deploy your application by following these steps:<br/>
   >  **1.** shutdown the running server `http-server`<br/>
      **2.** build and deploy `ToDoApplication` by running the following command: <br/>  
   >
   ```bash
   ng build ToDoApplication && http-server -p 8081 -c-1 dist/to-do-application
   ```

Once **ToDoApplication** is up and running, go ahead navigate to [http://localhost:8081](http://localhost:8081) <br/>

Here is what your application looks like:<br/>

<figure align="center">
	<a href="{{ site.baseurl }}/assets/tutorial/developer/13-todoapplication-after-todoarea-crud-generated.png">
    <img src="{{ site.baseurl }}/assets/tutorial/developer/13-todoapplication-after-todoarea-crud-generated.png" alt="ToDoApplication - After Generating ToDoArea Use Cases">
      <figcaption>ToDoApplication - After Generating ToDoArea Use Cases</figcaption>
  </a>
</figure>

Did you spot the new menu group item that was added to your application menu ?<br/>

Well, this menu group called `To Do Area`, was actually generated by the previous **averos workflow command** `advanced-crud`. <br/>

Let's go ahead and click on that item to unveil the items it hides.<br/>

Your ToDoApplication should look like the following:


<figure align="center">
	<a href="{{ site.baseurl }}/assets/tutorial/developer/14-todoapplication-todoarea-menu.png">
    <img src="{{ site.baseurl }}/assets/tutorial/developer/14-todoapplication-todoarea-menu.png" alt="ToDoApplication - ToDoArea Use Cases menu">
      <figcaption>ToDoApplication - ToDoArea Use Cases menu</figcaption>
  </a>
</figure>

>‚ÑπÔ∏è `averos use cases commands workflow` automatically generates default menu items for each use case.
By default, these menu items stand as routes to different use case components but can be customized at your will (grouping, translation, layout, visibility, target component...).<br/>
{: .notice--info}

Two main menu items could be identified at this point:
  - **Add To Do Area**
  - **Search To Do Area**




#### **2. `ToDoTask` Use Cases**

According to the design we made earlier, our `ToDoTask` entity is subject to the following actions:

>
  - [x] **Create**
  - [x] **Search** (based on criteria filter)
  - [x] **Export** (to Excel format)
  - [x] **Update/Modify**  
  - [x] **Delete**
  - [x] **Activate** a `ToDo Task` 
  - [x] **Close** a `ToDo Task`



### **V- Entity Composite Relation Use Cases**

We have been so far able to create most of the use cases defined in our ToDo tracking application requirements listed above. <br/>

One special use case worth nevertheless more attention seeing its complexity since its logic depends on the user requirements and thus could not be unified for all use cases.
This special use case concerns all entities relationships. Either it is a simple association, a composition or an aggregation it is obvious that handling such relationships depends on the final user needs. <br/>

Yet, **averos** defines some guidelines to follow when it comes to such use cases. Please refer to [Averos service apis naming conventions]({{ "/averos/getting-started-developer/reference-averos-service#averos-service-apis-naming-conventions/" | relative_url }}  "Averos Service APIs Naming Conventions") section and look at COMPOSITE API Logic Type. These are the conventions when dealing with entities relationships. <br/>

>üö© Notice that in this example averos has already added a `One To One` composite relationship between your business entities and the averos entity `User`.
The relationship is represented by the two class members `createdBy` and `updatedBy` and could be visible in all view use cases. 
{: .notice--warning}





#### **V.1- Displaying Relationship of type Collection in View, Edit and Create Use Cases**

There are a couple of thing to bear in mind when dealing with composite entity relationship in a context of **Create**, **View** or **Edit** entity.

`edit` and `view` entity use cases uses the mandatory auto-generated api `getEntityById(id: string)` located in the auto-generated averos service related to the entity subject to the action. So if you would like to display a `OneToMany` relationship by showing the collection of child items in a seperate tab then in `create`, `view` or `edit` parent mode your api should return, aside from your parent entity, a collection of child items IDs to display. Those child items ids will be therefore used by the auto-generated entity Child service api `getEntitiesByIds(ids: string[]): Observable<any>` in order to retrieve the related Child collection. 


So, given a parent entity, if you are willing to display child items within a `create`, an `edit` or a `view` entity use case you need to adapt you backend api so that : <br/>
- Within the Parent service, `getEntityById(id: string)` should return aside from the parent entity the list Child ids collection
- Decide which strategy you will follow when updating/creating a One to Many relationships: Update happens in a `single` transaction (one api call: one call to the parent api- delete, create or update- will handle the childs items) or `multiple` transactions (multiple api call: call child's api then parent api). Either way, you should mind these aspects when designing your API logic. Please refer to [averos entity update strategy]({{"/averos/documentation/references-and-conventions/reference-averos-entity/#a--single-transaction-strategy" | relative_url }} "Averos Entity Update Strategy") to learn more about update strategies that come with averos.


>üö© Note that **relationship update strategy** is customizable using the averos workflow command `add-composite-member` by setting the flag `--member-update-strategy` to either `single` or `multiple`. The related logic implementation will be automatically generated for you by the command workflow.
{: .notice--success}




