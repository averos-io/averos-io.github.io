---
title: "Reference"
permalink: /averos/docs/reference-averos-entity/
excerpt: "Reference -  averos entity"
toc: true
---

## **Averos Entity**


Averos entities are simple plain classes entities that, in addition to typescript/javascript compliancy, should follow the averos conventions while being inserted. <br/>
Averos conventions are: <br/>
- [X] Identify your entity identifier member and decorate it with the averos **@ID()** decorator
- [X] **One to one** relationship should be annotated/decorated with **@OneToOne()** decorator
- [X] **Many to one** relationship should be annotated/decorated with the **@ManyToOne()** decorator
- [X] **One to many** relationship should be annotated/decorated with the **@OneToMany()** decorator

**Averos workflow** allows to add new entities throught the following averos workflow command:

```bash
    ng g @wiforge/averos:add-composite-member --ename=[Your Entity Name] --fename=[your composite new member entity name] --fieldRelationType=[the relationship type] --member-update-strategy=[the update strategy]
```

> ðŸš© **ProTip**: 
> 
> **fieldRelationType** : Defines the relation type between two entities. It could have one of the following values:
   - **OneToOne**
   - **ManyToOne**
   - **OneToMany**
>
> **member-update-strategy**: Defines the update strategy related to the parent-childs entity relationship in a One-To-Many context. This flag could have two values:
   - **single**
   - **multiple**
{: .notice--success}

### **Notable consideration when dealing with navigeable One-To-Many relationships**

Given two entities `P`, as the relationShip owner or the Parent, and `C`, as the Child, which are linked by a `OneToMany` relationship; if you are willing to display child items within the parent in the context of `create`, `edit` or `view` entity use case then you are likely requesting a navigeable `OneToMany` relationship into which `P` is aware of its `C` items.
Handling such type of relationship is highly coupled with the design to follow in terms of update strategy.
While in real life applications there are several design patterns that were put in place in order to address this type of relations, **averos** has put in place the most relevant and natural update strategies that involves either a `single` transaction or `multiple` transactions. 

#### **a- Single Transaction Strategy**

A single transaction strategy means that when updating `P` by adding or deleting new `C`s to/from the `P->C` collection relationship, the related update will happen in a `single` transaction that usually relates to a simple `P` entity api call. 
The whole update logic is therefore managed by the back end that affords the api.
In such case, when calling an update api, the api will be in charge of updating the `P` relations by updating each child seperately before updating the parent. It will deal with exceptions and decide wether to cancel the update or to proceed with the partial updates.

#### **b- Multiple Transaction Strategy**

Multiple transcation strategy means that when updating `P` by adding or deleting new `C`s to/from the `P->C` collection relationship, the related update will happen in  `multiple` transactions that usually relate to multiple call to `C` api followed by a call to `P`  api.
The whole update logic is therefore managed by the front end service (the web application averos service) that is triggering the update.
In such case, the front end application will be in charge of handling exceptions and decide wether to cancel the update or to proceed with the partial updates.


>ðŸš© Note that relationship update strategy is available in the `add-composite-member` by setting the flag `--member-update-strategy` to either `single` or `multiple`. The related methods implementation will be automatically generated by the workflow.
{: .notice--success}


ðŸ“¢ More on this topic will be available soon in the ongoing averos documentation.
{: .notice--info}